"""
src/engine/response.py

This module is responsible for turning computed query results into a human-readable
assistant response, enriched with lightweight provenance information.

It does NOT perform any data aggregation or calculations. All metrics and tables are
produced by QueryEngine. This module focuses purely on formatting and explanation.

Responsibilities:

- Build a concise natural-language summary of the computed result table:
  • aggregate totals → prints metric values
  • top-N queries → prints a ranked preview
  • trend queries → explains the group-by dimension and the metrics involved

- Compute provenance metadata from the filtered dataset subset:
  • rows_used — number of rows involved in the computation
  • date range — min/max date of the subset
  • sample_row_ids — deterministic identifiers of example rows

The dataset subset is generated by QueryEngine.execute_with_subset(), ensuring that
provenance reflects the exact data used to produce the result.

The goal is to make results transparent and interpretable.
"""

from __future__ import annotations

from dataclasses import dataclass
import pandas as pd

from .query_plan import QueryPlan


@dataclass(frozen=True)
class Provenance:
    rows_used: int
    min_date: str
    max_date: str
    sample_row_ids: list[str]


class ResponseBuilder:
    @staticmethod
    def compute_provenance(subset_df: pd.DataFrame, sample_n: int = 10) -> Provenance:
        if len(subset_df) == 0:
            return Provenance(rows_used=0, min_date="N/A", max_date="N/A", sample_row_ids=[])

        min_d = str(subset_df["date"].min().date())
        max_d = str(subset_df["date"].max().date())

        sample_ids = []
        if "row_id" in subset_df.columns:
            sample_ids = subset_df["row_id"].dropna().astype(str).head(sample_n).tolist()

        return Provenance(
            rows_used=int(len(subset_df)),
            min_date=min_d,
            max_date=max_d,
            sample_row_ids=sample_ids,
        )

    @staticmethod
    def build_message(plan: QueryPlan, prov: Provenance, result_df: pd.DataFrame) -> str:
        if prov.rows_used == 0 or result_df is None or len(result_df) == 0:
            return (
                "I couldn't find any rows matching your request.\n\n"
                "Try changing the year/quarter or removing some filters.\n\n"
                "Is there anything else you'd like to explore?"
            )

        summary = ResponseBuilder._summarize_result(plan, result_df)

        sample = ", ".join(prov.sample_row_ids[:5]) if prov.sample_row_ids else "N/A"
        return (
            f"{summary}\n\n"
            f"Data used: {prov.rows_used} rows, date range {prov.min_date} → {prov.max_date}.\n"
            f"Sample row_id(s): {sample}\n\n"
            "Is there anything else you'd like to explore?"
        )

    @staticmethod
    def _summarize_result(plan: QueryPlan, result_df: pd.DataFrame) -> str:
        """
        Creates a short human-readable summary from the result table.
        
        For aggregate queries, it lists the computed metrics.
        For top-N queries, it provides a ranked list of the top results.
        For trend queries, it describes the group-by dimension and the metrics.
        """
        # Total (aggregate without groupby): usually 1 row
        if plan.intent == "aggregate" and (not plan.groupby) and len(result_df) == 1:
            parts = []
            for m in plan.metrics:
                if m in result_df.columns:
                    val = float(result_df.iloc[0][m])
                    parts.append(f"{m}: {val:,.2f}")
            if parts:
                return "Result (total): " + " | ".join(parts)
            return "Result computed (see table)."

        # Top-N: print a short ranked list
        if plan.intent == "top_n" and plan.groupby and len(result_df) > 0:
            dim = plan.groupby[0]
            metric = (plan.sort_by.field if plan.sort_by else (plan.metrics[0] if plan.metrics else "revenue"))
            lines = []
            for i in range(min(5, len(result_df))):
                name = str(result_df.iloc[i][dim])
                val = float(result_df.iloc[i][metric]) if metric in result_df.columns else None
                if val is not None:
                    lines.append(f"{i+1}. {name} — {metric}: {val:,.2f}")
                else:
                    lines.append(f"{i+1}. {name}")
            return "Top results:\n" + "\n".join(lines)

        # Trend: describe table content
        if plan.intent == "trend":
            metrics = ", ".join(plan.metrics or [])
            group = ", ".join(plan.groupby or [])
            return f"Trend table computed (grouped by {group}). Metrics: {metrics}. See the table for values."

        return "Result computed (see table)."